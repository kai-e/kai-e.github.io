(xormod
 (xor_bit_TCC1 0
  (xor_bit_TCC1-1 nil 3884718627 ("" (cond-coverage-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nbit type-eq-decl nil bit nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (xor_bit coverage
    "COND xormod.c = 0 -> 0, xormod.c = 1 -> 1 ENDCOND" "nil")))
 (xor_bit_TCC2 0
  (xor_bit_TCC2-1 nil 3884718627 ("" (cond-coverage-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nbit type-eq-decl nil bit nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (xor_bit coverage
    "COND xormod.c = 0 -> 1, xormod.c = 1 -> 0 ENDCOND" "nil")))
 (xor_bit_TCC3 0
  (xor_bit_TCC3-1 nil 3884718627 ("" (cond-coverage-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nbit type-eq-decl nil bit nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (xor_bit coverage "TABLE b, c
     %+---+---++
     |[ 0 | 1 ]|
  %---+---+---++
  | 0 | 0 | 1 ||
  %---+---+---++
  | 1 | 1 | 0 ||
  %---+---+---++
ENDTABLE" "nil")))
 (xor_bit_comm 0
  (xor_bit_comm-1 nil 3884726870 ("" (grind) nil nil)
   ((xor_bit const-decl "nbit" xormod nil)
    (nbit type-eq-decl nil bit nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (xor_bit_assoc 0
  (xor_bit_assoc-1 nil 3884726876 ("" (grind) nil nil)
   ((xor_bit const-decl "nbit" xormod nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nbit type-eq-decl nil bit nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (xor_bit_cancel 0
  (xor_bit_cancel-1 nil 3884726880 ("" (grind) nil nil)
   ((xor_bit const-decl "nbit" xormod nil)) shostak))
 (xor_bit_zero0 0
  (xor_bit_zero0-1 nil 3884726884 ("" (grind) nil nil)
   ((xor_bit const-decl "nbit" xormod nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nbit type-eq-decl nil bit nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (xor_bit_zero1 0
  (xor_bit_zero1-1 nil 3884726971 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nbit type-eq-decl nil bit nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (xor_bit const-decl "nbit" xormod nil))
   shostak))
 (xor_nat_TCC1 0
  (xor_nat_TCC1-1 nil 3884718627 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil))
   nil (xor_nat subtype "xormod.n2" "nat")))
 (xor_nat_TCC2 0
  (xor_nat_TCC2-1 nil 3884718627 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil))
   nil (xor_nat subtype "xormod.m2" "nat")))
 (xor_nat_TCC3 0
  (xor_nat_TCC3-1 nil 3884718627 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil))
   nil
   (xor_nat termination "xormod.xor_nat(xormod.n2, xormod.m2)" "nil")))
 (xor_nat_comm 0
  (xor_nat_comm-1 nil 3884726761
   ("" (induct "n" :name "NAT_induction")
    (("" (skeep)
      (("" (induct "m" :name "NAT_induction")
        (("" (skeep)
          (("" (expand "xor_nat" 1)
            (("" (inst -1 "ndiv(j_1,2)")
              (("" (inst -2 "ndiv(j,2)")
                (("" (prop)
                  (("1" (ground)
                    (("1" (inst -1 "ndiv(j_1,2)")
                      (("1" (replace -1 * LR)
                        (("1" (lemma "xor_bit_comm")
                          (("1" (inst -1 "rem(2)(j)" "rem(2)(j_1)")
                            (("1" (replace -1 * LR)
                              (("1"
                                (delete -)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (ground)
                    (("2" (case "j = 0")
                      (("1" (grind) nil nil)
                       ("2" (typepred "ndiv(j, 2)")
                        (("2" (delete 3 -3) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (ground)
                    (("3" (inst -1 "ndiv(j_1, 2)")
                      (("3" (grind) nil nil)) nil))
                    nil)
                   ("4" (ground)
                    (("4" (case "j = 0")
                      (("1" (grind) nil nil)
                       ("2" (delete 3 4)
                        (("2" (typepred "ndiv(j, 2)")
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nil application-judgement "upto(n)" modulo_arithmetic nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (ndiv const-decl "{q: int | x = b * q + rem(b)(x)}"
     modulo_arithmetic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nbit type-eq-decl nil bit nil)
    (xor_bit const-decl "nbit" xormod nil)
    (xor_bit_comm formula-decl nil xormod nil)
    (NAT_induction formula-decl nil naturalnumbers nil)
    (xor_nat def-decl "nat" xormod nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (xor_nat_cancel 0
  (xor_nat_cancel-1 nil 3884728720
   ("" (induct "n" :name "NAT_induction")
    (("" (skeep)
      (("" (expand "xor_nat" +)
        (("" (case "j = 0")
          (("1" (grind) nil nil)
           ("2" (assert)
            (("2" (inst -1 "ndiv(j, 2)")
              (("2" (assert)
                (("2" (replace -1 * LR)
                  (("2" (lemma "xor_bit_cancel")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (ndiv const-decl "{q: int | x = b * q + rem(b)(x)}"
     modulo_arithmetic nil)
    (xor_bit const-decl "nbit" xormod nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (xor_bit_cancel formula-decl nil xormod nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nil application-judgement "upto(n)" modulo_arithmetic nil)
    (NAT_induction formula-decl nil naturalnumbers nil)
    (xor_nat def-decl "nat" xormod nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (xor_nat_zero0 0
  (xor_nat_zero0-1 nil 3884728906
   ("" (induct "n" :name "NAT_induction")
    (("" (skeep) (("" (expand "xor_nat" +) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (NAT_induction formula-decl nil naturalnumbers nil)
    (xor_nat def-decl "nat" xormod nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (xor_nat_zero1 0
  (xor_nat_zero1-1 nil 3884728966
   ("" (lemma "xor_nat_comm")
    (("" (lemma "xor_nat_zero0") (("" (grind) nil nil)) nil)) nil)
   ((xor_nat_zero0 formula-decl nil xormod nil)
    (xor_nat def-decl "nat" xormod nil)
    (xor_nat_comm formula-decl nil xormod nil))
   shostak))
 (xor_nat_one_even 0
  (xor_nat_one_even-1 nil 3884729381
   ("" (induct "n" :name "NAT_induction")
    (("" (skeep)
      (("" (expand "xor_nat" +)
        (("" (expand "even?")
          (("" (skeep -2)
            (("" (replace -2 * LR)
              (("" (lemma "rem_multiple1")
                (("" (inst -1 "2" "j_1")
                  (("" (replace -1 * LR)
                    (("" (rewrite "xor_bit_zero1" + ("c" "rem(2)(1)"))
                      (("" (case "ndiv(1, 2) = 1")
                        (("1" (replace -1 * LR)
                          (("1" (case "rem(2)(1) = 1")
                            (("1" (replace -1 * LR)
                              (("1"
                                (case "ndiv(2 * j_1, 2) = j_1")
                                (("1"
                                  (replace -1 * LR)
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (typepred "ndiv(2 * j_1, 2)")
                                  (("2"
                                    (delete -5 2)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (delete -3 2) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (typepred "ndiv(1, 2)")
                          (("2" (delete 1)
                            (("2" (case "ndiv(1,2) = 0")
                              (("1" (grind) nil nil)
                               ("2"
                                (delete -4 -5 2)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (even? const-decl "bool" integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (xor_nat def-decl "nat" xormod nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NAT_induction formula-decl nil naturalnumbers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (rem_multiple1 formula-decl nil modulo_arithmetic nil)
    (nil application-judgement "upto(n)" modulo_arithmetic nil)
    (ndiv const-decl "{q: int | x = b * q + rem(b)(x)}"
     modulo_arithmetic nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (<= const-decl "bool" reals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (nbit type-eq-decl nil bit nil) (< const-decl "bool" reals nil)
    (xor_bit_zero1 formula-decl nil xormod nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (xor_nat_one_odd 0
  (xor_nat_one_odd-1 nil 3884732123
   ("" (induct "n" :name "NAT_induction")
    (("" (skeep)
      (("" (expand "xor_nat" +)
        (("" (expand "odd?")
          (("" (skeep -2)
            (("" (replace -2 * LR)
              (("" (case "rem(2)(1 + 2 * j_1) = 1")
                (("1" (replace -1 * LR)
                  (("1" (lift-if)
                    (("1" (ground)
                      (("1" (case "rem(2)(1) = 1")
                        (("1" (replace -1 * LR)
                          (("1" (expand "xor_bit")
                            (("1" (case "ndiv(1,2) = 0")
                              (("1"
                                (replace -1 * LR)
                                (("1"
                                  (lemma "xor_nat_zero0")
                                  (("1"
                                    (inst? -1)
                                    (("1"
                                      (replace -1 * LR)
                                      (("1" (ground) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (ground) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (ground) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -1 -2 2)
                  (("2" (lemma "rem_add_one")
                    (("2" (inst -1 "2" "2*j_1")
                      (("2" (ground)
                        (("2" (lemma "rem_multiple1")
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (rem_multiple1 formula-decl nil modulo_arithmetic nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (rem_add_one formula-decl nil modulo_arithmetic nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "upto(n)" modulo_arithmetic nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (ndiv const-decl "{q: int | x = b * q + rem(b)(x)}"
     modulo_arithmetic nil)
    (xor_nat_zero0 formula-decl nil xormod nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (xor_bit const-decl "nbit" xormod nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (NAT_induction formula-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (xor_nat def-decl "nat" xormod nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (odd? const-decl "bool" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (xor_nat_succ_even 0
  (xor_nat_succ_even-1 nil 3884733772
   ("" (skeep)
    (("" (expand "xor_nat")
      (("" (expand "even?")
        (("" (skeep)
          (("" (lift-if)
            (("" (ground)
              (("" (replace -1 * LR)
                (("" (grind)
                  ((""
                    (case "ndiv(2 * j, 2) = j AND ndiv(1 + 2 * j, 2) = j")
                    (("1" (prop)
                      (("1" (replace -1 * LR)
                        (("1" (replace -2 * LR)
                          (("1" (lemma "xor_nat_cancel")
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete 2 3 -1)
                      (("2" (grind)
                        (("1" (typepred "ndiv(1 + 2 * j, 2)")
                          (("1" (ground)
                            (("1" (lemma "rem_sum2")
                              (("1"
                                (inst -1 "2" "1" "2*j")
                                (("1"
                                  (lemma "rem_multiple1")
                                  (("1"
                                    (inst?)
                                    (("1" (ground) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (typepred "ndiv(2 * j, 2)")
                          (("2" (ground)
                            (("2" (lemma "rem_multiple1")
                              (("2"
                                (inst?)
                                (("2" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xor_nat def-decl "nat" xormod nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nil application-judgement "upto(n)" modulo_arithmetic nil)
    (xor_bit const-decl "nbit" xormod nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rem_sum2 formula-decl nil modulo_arithmetic nil)
    (rem_multiple1 formula-decl nil modulo_arithmetic nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (xor_nat_cancel formula-decl nil xormod nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (ndiv const-decl "{q: int | x = b * q + rem(b)(x)}"
     modulo_arithmetic nil)
    (even? const-decl "bool" integers nil))
   shostak))
 (xor_iter_TCC1 0
  (xor_iter_TCC1-1 nil 3884718627 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (xor_iter subtype "(number_fields.-)(xormod.n, 1)" "nat")))
 (xor_iter_TCC2 0
  (xor_iter_TCC2-1 nil 3884718627 ("" (termination-tcc) nil nil) nil
   nil
   (xor_iter termination
    "xormod.xor_iter((number_fields.-)(xormod.n, 1))" "nil")))
 (xor_iter_prop_TCC1 0
  (xor_iter_prop_TCC1-1 nil 3884718627 ("" (cond-coverage-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil))
   nil
   (xor_iter_prop coverage "TABLE
  %--------------+-------------------------------------------++
  | xormod.m = 0 | xormod.x = xormod.n                       ||
  %--------------+-------------------------------------------++
  | xormod.m = 1 | xormod.x = 1                              ||
  %--------------+-------------------------------------------++
  | xormod.m = 2 | xormod.x = (number_fields.+)(xormod.n, 1) ||
  %--------------+-------------------------------------------++
  | xormod.m = 3 | xormod.x = 0                              ||
  %--------------+-------------------------------------------++
ENDTABLE" "nil")))
 (xor_iter_prop 0
  (xor_iter_prop-1 nil 3884718681
   ("" (induct "n" 1)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (lemma "rem_def")
      (("6" (inst -1 "4" "0" "0")
        (("6" (ground)
          (("1" (lemma "rem_zero")
            (("1" (ground) (("1" (grind) nil nil)) nil)) nil)
           ("2" (lemma "rem_zero") (("2" (grind) nil nil)) nil)
           ("3" (expand "xor_iter") (("3" (propax) nil nil)) nil))
          nil))
        nil))
      nil)
     ("7" (skeep)
      (("7" (lemma "rem_def")
        (("7" (lemma "rem_add_one")
          (("7" (inst -1 "4" "j")
            (("7" (assert)
              (("7" (prop)
                (("1" (grind) nil nil)
                 ("2" (expand "xor_iter" +)
                  (("2" (lemma "xor_nat_succ_even")
                    (("2" (inst -1 "j")
                      (("2" (replace -4 * LR)
                        (("2" (assert)
                          (("2" (expand "even?")
                            (("2" (delete -1 -3 -4 2 3)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil) ("4" (grind) nil nil)
                 ("5" (grind) nil nil) ("6" (grind) nil nil)
                 ("7" (grind)
                  (("7" (case "2 + 4 * q!1 = 2 * (1 + 2 * q!1)")
                    (("1" (lemma "rem_multiple1")
                      (("1" (inst -1 "2" "1 + 2 * q!1")
                        (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("8" (grind) nil nil) ("9" (grind) nil nil)
                 ("10" (grind) nil nil) ("11" (grind) nil nil)
                 ("12" (delete 1 3 4 5 6)
                  (("12" (expand "xor_iter" 1)
                    (("12" (lemma "xor_nat_cancel")
                      (("12" (inst -1 "1+j") (("12" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("13" (grind) nil nil) ("14" (grind) nil nil)
                 ("15" (grind) nil nil) ("16" (grind) nil nil)
                 ("17" (grind) nil nil) ("18" (grind) nil nil)
                 ("19" (grind) nil nil) ("20" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (delete 2) (("8" (grind) nil nil)) nil))
    nil)
   ((even_times_int_is_even application-judgement "even_int" integers
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (xor_iter def-decl "nat" xormod nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (rem_zero formula-decl nil modulo_arithmetic nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (rem_def formula-decl nil modulo_arithmetic nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (xor_nat_succ_even formula-decl nil xormod nil)
    (even? const-decl "bool" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (rem_multiple1 formula-decl nil modulo_arithmetic nil)
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (nil application-judgement "upto(n)" modulo_arithmetic nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (xor_bit const-decl "nbit" xormod nil)
    (xor_nat def-decl "nat" xormod nil)
    (xor_nat_cancel formula-decl nil xormod nil)
    (rem_add_one formula-decl nil modulo_arithmetic nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak)))

