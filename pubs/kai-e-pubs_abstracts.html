<head>
  <link rel="stylesheet" href="/assets/css/style.css">
</head>

<!-- This document was automatically generated with bibtex2html 1.99
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html -both -s plain -nf HTTP "web site" -nf PDF PDF -nf PS PS -nokeywords -d -r -dl -nofooter -nodoc -html-entities -t "Publications by Kai&nbsp;Engelhardt (~) in reverse chronological order" kai-e-pubs.bib  -->

<h1>Publications by Kai&nbsp;Engelhardt (~) in reverse chronological order</h1>
<dl>

<dt>
[<a name="MSE2018euroSnP">1</a>]
</dt>
<dd>
Toby Murray, Robert Sison, and ~.
 Covern: A logic for compositional verification of
  information flow control.
 In Frank Piessens and Matthew Smith, editors, <em>IEEE European
  Symposium on Security and Privacy (EuroS&amp;P)</em>, April 2018.
[&nbsp;<a href="kai-e-pubs_bib.html#MSE2018euroSnP">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1109/EuroSP.2018.00010">DOI</a>&nbsp;| 
<a href="https://covern.org/papers/EuroSP18.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Shared memory concurrency is pervasive in modern
                  programming, including in systems that must protect
                  highly sensitive data. Recently, verification has
                  finally emerged as a practical tool for proving
                  interesting security properties of real programs,
                  particularly information flow control (IFC)
                  security. Yet there remain no general logics for
                  verifying IFC security of shared-memory concurrent
                  programs. In this paper we present the first such
                  logic, Covern (Compositional Verification
                  of Noninterference) and its proof of soundness via a
                  new generic framework for <em>general</em>
                  rely-guarantee IFC reasoning. We apply
                  Covern to model and verify the
                  security-critical software functionality of the
                  Cross Domain Desktop Compositor, an embedded device
                  that facilitates simultaneous and intuitive user
                  interaction with multiple classified networks while
                  preventing leakage between them. To our knowledge
                  this is the first foundational, machine-checked
                  proof of IFC security for a non-trivial
                  shared-memory concurrent program in the literature.
</font></blockquote>

</dd>


<dt>
[<a name="E2017qifca">2</a>]
</dt>
<dd>
~.
 A better composition operator for quantitative information flow
  analyses.
 In Simon&nbsp;N. Foley, Dieter Gollmann, and Einar Snekkenes, editors,
  <em>Computer Security &ndash; ESORICS 2017, 22nd European Symposium on Research
  in Computer Security Oslo, Norway, September 11&ndash;15, 2017, Proceedings, Part
  I</em>, volume 10492 of <em>LNCS</em>, pages 446&ndash;463, Oslo, Norway, September
  11&ndash;13 2017. Springer-Verlag.
[&nbsp;<a href="kai-e-pubs_bib.html#E2017qifca">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/978-3-319-66402-6_26">DOI</a>&nbsp;]
<blockquote><font size="-1">
Given a description of the quantitative information
                  flow (qif) for components, how can we determine the
                  qif of a system composed from components? We explore
                  this fundamental question mathematically and provide
                  an answer based on a new composition operator. We
                  investigate its properties and prove that it
                  generalises existing composition operators. We
                  illustrate the results with a fresh look on Chaum's
                  dining cryptographers. We show that the new operator
                  enjoys various convenient algebraic properties and
                  that it is well-behaved under composition
                  refinement.
</font></blockquote>

</dd>


<dt>
[<a name="GHE2015:PLDI">3</a>]
</dt>
<dd>
Peter Gammie, Antony&nbsp;L. Hosking, and ~.
 Relaxing safely: Verified on-the-fly garbage collection for
  x86-TSO.
 In Steve Blackburn, editor, <em>PLDI 2015, 36th annual ACM
  SIGPLAN conference on Programming Language Design and Implementation</em>, pages
  99&ndash;109, Portland, OR, May 2015. ACM.
[&nbsp;<a href="kai-e-pubs_bib.html#GHE2015:PLDI">bib</a>&nbsp;]
<blockquote><font size="-1">
We report on a machine-checked verification of
                  safety for a state-of-the-art, on-the-fly,
                  concurrent, mark-sweep garbage collector that is
                  designed for multi-core architectures with weak
                  memory consistency. The proof explicitly
                  incorporates the relaxed memory semantics of x86
                  multiprocessors. To our knowledge, this is the first
                  fully machine-checked proof of safety for such a
                  garbage collector. We couch the proof in a framework
                  that system implementers will find appealing, with
                  the fundamental components of the system specified
                  in a simple and intuitive programming language. The
                  abstract model is detailed enough for its
                  correspondence with an assembly language
                  implementation to be straightforward.
</font></blockquote>

</dd>


<dt>
[<a name="GHE2015:afp">4</a>]
</dt>
<dd>
Peter Gammie, Tony Hosking, and ~.
 Relaxing safely: Verified on-the-fly garbage collection for
  x86-TSO.
 <em>Archive of Formal Proofs</em>, 2015.
[&nbsp;<a href="kai-e-pubs_bib.html#GHE2015:afp">bib</a>&nbsp;| 
<a href="http://afp.sourceforge.net/entries/ConcurrentGC.shtml">http</a>&nbsp;]
<blockquote><font size="-1">
We use ConcurrentIMP to model Schism, a
                  state-of-the-art real-time garbage collection scheme
                  for weak memory, and show that it is safe on
                  x86-TSO.
                  This development accompanies the PLDI 2015
                  paper of the same name.
</font></blockquote>

</dd>


<dt>
[<a name="EvdMZ2012a">5</a>]
</dt>
<dd>
~, Ron van&nbsp;der Meyden, and Chenyi Zhang.
 Intransitive noninterference in nondeterministic systems.
 In Ting Yu, George Danezis, and Virgil&nbsp;D. Gligor, editors, <em>19th
  ACM Conference on Computer and Communications Security</em>. ACM, October 2012.
[&nbsp;<a href="kai-e-pubs_bib.html#EvdMZ2012a">bib</a>&nbsp;]
<blockquote><font size="-1">
This paper addresses the question of how
                  TA-security, a semantics for intransitive
                  information-flow policies in deterministic systems,
                  can be generalized to nondeterministic systems.
                  Various definitions are proposed, including
                  definitions that state that the system enforces as
                  much of the policy as possible in the context of
                  attacks in which groups of agents collude by sharing
                  information through channels that lie outside the
                  system. Relationships between the various
                  definitions proposed are characterized, and an
                  unwinding-based proof technique is developed.
                  Finally, it is shown that on a specific class of
                  systems, access control systems with local
                  non-determinism, the strongest definition can be
                  verified by checking a simple static property.
</font></blockquote>

</dd>


<dt>
[<a name="Klein_EH_10:cacm">6</a>]
</dt>
<dd>
Gerwin Klein, June Andronick, Kevin Elphinstone, Gernot Heiser, David Cock,
  Philip Derrin, Dhammika Elkaduwe, ~, Rafal Kolanski, Michael
  Norrish, Thomas Sewell, Harvey Tuch, and Simon Winwood.
 seL4: Formal verification of an operating-system kernel.
 <em>Communications of the ACM</em>, 53(6):107&ndash;115, June 2010.
[&nbsp;<a href="kai-e-pubs_bib.html#Klein_EH_10:cacm">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/1743546.1743574">DOI</a>&nbsp;]
<blockquote><font size="-1">
We report on the formal, machine-checked
                  verification of the seL4 microkernel from an
                  abstract specification down to its C implementation.
                  We assume correctness of compiler, assembly code,
                  hardware, and boot code. seL4 is a third-generation
                  microkernel of L4 provenance, comprising 8,700 lines
                  of C and 600 lines of assembler. Its performance is
                  comparable to other high-performance L4 kernels. We
                  prove that the implementation always strictly
                  follows our high-level abstract specification of
                  kernel behaviour. This encompasses traditional
                  design and implementation safety properties such as
                  that the kernel will never crash, and it will never
                  perform an unsafe operation. It also implies much
                  more: we can predict precisely how the kernel will
                  behave in every possible situation.
</font></blockquote>

</dd>


<dt>
[<a name="E2010:ARSPA_WITS">7</a>]
</dt>
<dd>
~.
 A note on noninterference in the presence of colluding adversaries
  (preliminary report).
 Presented at Automated Reasoning for Security Protocol Analysis and
  Issues in the Theory of Security, ARSPA-WITS'10, March 27&ndash;28 2010.
[&nbsp;<a href="kai-e-pubs_bib.html#E2010:ARSPA_WITS">bib</a>&nbsp;]
<blockquote><font size="-1">
Whether adversaries can glean information from a
                  distributed system in a formal sense hinges on the
                  definition of such a system and what can be observed
                  by those agents. In the presence of colluding
                  adversaries, the standard definition of
                  non-interference by Goguen and Meseguer and its many
                  variants proposed in the literature fail in a very
                  intuitive sense to capture a simple collusion
                  attack. The crucial difference between what is
                  modelled in those definitions and what we argue
                  needs to be modelled is that <em>teams can observe
                  pomsets</em> as Plotkin and Pratt stated. In this note
                  we expose what goes wrong in the known approaches
                  and explain how to fix the problem.
</font></blockquote>

</dd>


<dt>
[<a name="EH2008">8</a>]
</dt>
<dd>
~ and Ralf Huuck.
 Smaller abstractions for &forall;CTL<sup>*</sup> without Next.
 In Dennis Dams, Ulrich Hannemann, and Martin Steffen, editors, <em>
  Concurrency, Compositionality, and Correctness: Essays in Honor of
  Willem-Paul de Roever</em>, volume 5930 of <em>LNCS</em>, pages 250&ndash;259.
  Springer-Verlag, 2010.
[&nbsp;<a href="kai-e-pubs_bib.html#EH2008">bib</a>&nbsp;]
<blockquote><font size="-1">
The success of applying model-checking to large
                  systems depends crucially on the choice of good
                  abstractions. In this work we present an approach
                  for constructing abstractions when checking
                  next-free universal CTL<sup>*</sup> properties. It is known
                  that functional abstractions are safe and that
                  next-free universal CTL<sup>*</sup> is insensitive to finite
                  stuttering. We exploit these results by introducing
                  a safe <em>next-free abstraction</em> that is
                  typically smaller than the usual functional one
                  while at the same time more precise, i.e., it has
                  less spurious counter-examples.
</font></blockquote>

</dd>


<dt>
[<a name="Klein_EH_09">9</a>]
</dt>
<dd>
Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock,
  Philip Derrin, Dhammika Elkaduwe, ~, Rafal Kolanski, Michael
  Norrish, Thomas Sewell, Harvey Tuch, and Simon Winwood.
 seL4: Formal verification of an OS kernel.
 In <em>Proceedings of the 22nd ACM Symposium on Operating Systems
  Principles (SOSP)</em>, pages 207&ndash;220, Big Sky, MT, USA, October 2009. ACM.
[&nbsp;<a href="kai-e-pubs_bib.html#Klein_EH_09">bib</a>&nbsp;| 
<a href="http://www.sigops.org/sosp/sosp09/papers/klein-sosp09.pdf">PDF</a>&nbsp;]

</dd>


<dt>
[<a name="EM2009dc">10</a>]
</dt>
<dd>
~ and Yoram Moses.
 Causing communication closure: safe program composition with reliable
  non-FIFO channels.
 <em>Distributed Computing</em>, 22(2):73&ndash;91, October 2009.
[&nbsp;<a href="kai-e-pubs_bib.html#EM2009dc">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/s00446-009-0081-9">DOI</a>&nbsp;]
<blockquote><font size="-1">
A rigorous framework for analyzing safe composition
                  of distributed programs is presented. It facilitates
                  specifying notions of safe sequential execution of
                  distributed programs in various models of
                  communication. A notion of <em>sealing</em> is
                  defined, where if a program <em>P</em> is immediately
                  followed by a program <em>Q</em> that seals <em>P</em> then <em>P</em>
                  will be communication-closed&mdash;it will execute as if
                  it runs in isolation. None of its send or receive
                  actions will match or interact with actions
                  outside <em>P</em>. The applicability of sealing is
                  illustrated by a study of program composition when
                  communication is reliable but not necessarily
                  FIFO . In this model, special care must be taken to
                  ensure that messages do not accidentally overtake
                  one another in the composed program. In this model
                  no program that sends or receives messages can be
                  composed automatically with arbitrary programs
                  without jeopardizing their intended behavior. Safety
                  of composition becomes context-sensitive and new
                  tools are needed for ensuring it. The investigation
                  of sealing in this model reveals a novel connection
                  between Lamport causality and safe composition. A
                  characterization of sealable programs is given, as
                  well as efficient algorithms for testing if <em>Q</em>
                  seals <em>P</em> and for constructing a seal for a class of
                  straight-line programs. It is shown that every
                  sealable program can be sealed using <em>O</em>(<em>n</em>)
                  messages. In fact, 3<em>n</em>-4 messages are necessary and
                  sufficient in the worst case, despite the fact that
                  a sealable program may be open to interference on
                  &Omega;(<em>n</em><sup>2</sup>) channels.
</font></blockquote>

</dd>


<dt>
[<a name="EM2008ipl">11</a>]
</dt>
<dd>
~ and Yoram Moses.
 Single-bit messages are insufficient for data link over duplicating
  channels.
 <em>Information Processing Letters</em>, 107(6):235&ndash;239, August 2008.
[&nbsp;<a href="kai-e-pubs_bib.html#EM2008ipl">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1016/j.ipl.2008.03.010">DOI</a>&nbsp;]
<blockquote><font size="-1">
Ideal communication channels in asynchronous
                  systems are reliable, deliver messages in FIFO
                  order, and do not deliver spurious or duplicate
                  messages. A message vocabulary of size two (i.e.,
                  single-bit messages) suffices to encode and transmit
                  messages of arbitrary finite length over such
                  channels. This note proves that single-bit messages
                  are insufficient once channels potentially deliver
                  duplicate messages. In particular, it is shown that
                  no protocol allows the sender to notify the receiver
                  which of three values it holds, over a
                  bidirectional, reliable, FIFO channel that may
                  duplicate messages. This implies that messages must
                  encode some additional control information, e.g., in
                  the form of headers or tags.
</font></blockquote>

</dd>


<dt>
[<a name="EGvdM2007:LFCS">12</a>]
</dt>
<dd>
~, Peter Gammie, and Ron van&nbsp;der Meyden.
 Model checking knowledge and linear time: PSPACE cases.
 In Sergei&nbsp;N. Art&euml;mov and Anil Nerode, editors, <em>Logical
  Foundations of Computer Science, International Symposium, LFCS 2007, New
  York, NY, USA, June 4-7, 2007, Proceedings</em>, volume 4514 of <em>LNCS</em>, pages
  195&ndash;211. Springer-Verlag, June 2007.
[&nbsp;<a href="kai-e-pubs_bib.html#EGvdM2007:LFCS">bib</a>&nbsp;]
<blockquote><font size="-1">
We present a general algorithm scheme for model
                  checking logics of knowledge, common knowledge and
                  linear time, based on simulations to a class of
                  structures that capture the way that agents update
                  their knowledge. We show that the scheme leads to
                  PSPACE implementations of model checking the logic
                  of knowledge and linear time in several special
                  cases: perfect recall systems with a single agent or
                  in which all communication is by synchronous
                  broadcast, and systems in which knowledge is
                  interpreted using either the agents' current
                  observation only or its current observation and
                  clock value. In all these results, common knowledge
                  operators may be included in the language. Matching
                  lower bounds are provided, and it is shown that
                  although the complexity bound matches the PSPACE
                  complexity of the linear time temporal logic LTL, as
                  a function of the model size the problems considered
                  have a higher complexity than LTL.
</font></blockquote>

</dd>


<dt>
[<a name="EM2005c">13</a>]
</dt>
<dd>
~ and Yoram Moses.
 Single-bit messages are insufficient in the presence of duplication.
 In Ajit Pal, Ajay Kshemkalyani, Rajeev Kumar, and Arobinda Gupta,
  editors, <em>7<sup></sup><em>th</em> International Workshop on Distributed Computing
  IWDC 2005</em>, volume 3741 of <em>LNCS</em>, pages 25&ndash;31. Springer-Verlag,
  December 27&ndash;30 2005.
[&nbsp;<a href="kai-e-pubs_bib.html#EM2005c">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/11603771_3">DOI</a>&nbsp;]
<blockquote><font size="-1">
Ideal communication channels in asynchronous systems
                  are reliable, deliver messages in FIFO order, and do
                  not deliver spurious or duplicate messages. A
                  message vocabulary of size two (i.e., single-bit
                  messages) suffices to encode and transmit messages
                  of arbitrary finite length over such channels. This
                  note proves that single-bit messages are
                  insufficient once channels potentially deliver
                  duplicate messages. In particular, it is shown that
                  no protocol allows the sender to notify the receiver
                  which of three values it holds, over a
                  bidirectional, reliable, FIFO channel that may
                  duplicate messages. This implies that messages must
                  encode some additional control information, e.g., in
                  the form of headers or tags.
</font></blockquote>

</dd>


<dt>
[<a name="EM2005b">14</a>]
</dt>
<dd>
~ and Yoram Moses.
 Safe composition of distributed programs communicating over
  order-preserving imperfect channels.
 In Ajit Pal, Ajay Kshemkalyani, Rajeev Kumar, and Arobinda Gupta,
  editors, <em>7<sup></sup><em>th</em> International Workshop on Distributed Computing
  IWDC 2005</em>, volume 3741 of <em>LNCS</em>, pages 32&ndash;44. Springer-Verlag,
  December 27&ndash;30 2005.
[&nbsp;<a href="kai-e-pubs_bib.html#EM2005b">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/11603771_4">DOI</a>&nbsp;]
<blockquote><font size="-1">
The fundamental question considered in this paper is
                  when program <em>Q</em>, if executed immediately after
                  program <em>P</em>, is guaranteed not to interfere with <em>P</em>
                  and be safe from interference by <em>P</em>. If a message
                  sent by one of these programs is received by the
                  other, it may affect and modify the other's
                  execution. The notion of <em>communication-closed
                  layers (CCLs)</em> introduced by Elrad and Francez in
                  1982 is a useful tool for studying such
                  interference. CCLs have been considered mainly in
                  the context of reliable FIFO channels (without
                  duplication), where one can design programs layers
                  that do not interfere with any other layer. When
                  channels are less than perfect such programs are no
                  longer feasible. The absence of interference between
                  layers becomes context-dependent. In this paper we
                  study the impact of message duplication and loss on
                  the safety on the safety of layer composition. Using
                  a communication phase operator, the <em>fits
                  after</em> relation among programs is defined. If
                  program <em>Q</em> fits after <em>P</em> then <em>P</em> and <em>Q</em> will not
                  interfere with each other in executions of <em>P</em>*<em>Q</em>.
                  For programs <em>P</em> and <em>Q</em> in a natural class of
                  programs we outline efficient algorithms for the
                  following: (1) deciding whether <em>Q</em> fits after <em>P</em>;
                  (2) deciding whether <em>Q</em> <em>seals</em> <em>P</em>, meaning
                  that <em>Q</em> fits after <em>P</em> and no following program can
                  communicate with <em>P</em>; and (3) constructing a
                  <em>separator</em> <em>S</em> that both fits after <em>P</em> and
                  satisfies that <em>Q</em> fits after <em>P</em>*<em>S</em>.
</font></blockquote>

</dd>


<dt>
[<a name="EM2005a">15</a>]
</dt>
<dd>
~ and Yoram Moses.
 Causing communication closure: Safe program composition with
  non-FIFO channels.
 In Pierre Fraigniaud, editor, <em>DISC 2005 19<sup></sup><em>th</em>
  International Symposium on Distributed Computing</em>, volume 3724 of <em>LNCS</em>,
  pages 229&ndash;243. Springer-Verlag, September 26&ndash;29 2005.
[&nbsp;<a href="kai-e-pubs_bib.html#EM2005a">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/11561927_18">DOI</a>&nbsp;]
<blockquote><font size="-1">
A semantic framework for analyzing safe composition
                  of distributed programs is presented. Its
                  applicability is illustrated by a study of program
                  composition when communication is reliable but not
                  necessarily FIFO . In this model, special care must
                  be taken to ensure that messages do not accidentally
                  overtake one another in the composed program. We
                  show that barriers do not exist in this model.
                  Indeed, no program that sends or receives messages
                  can automatically be composed with arbitrary
                  programs without jeopardizing their intended
                  behavior. Safety of composition becomes
                  context-sensitive and new tools are needed for
                  ensuring it. A notion of <em>sealing</em> is defined,
                  where if a program <em>P</em> is immediately followed by a
                  program <em>Q</em> that seals <em>P</em> then <em>P</em> will be
                  communication-closed&mdash;it will execute as if it runs
                  in isolation. The investigation of sealing in this
                  model reveals a novel connection between Lamport
                  causality and safe composition. A characterization
                  of sealable programs is given, as well as efficient
                  algorithms for testing if <em>Q</em> seals <em>P</em> and for
                  constructing a seal for a significant class of
                  programs. It is shown that every sealable program
                  that is open to interference on <em>O</em>(<em>n</em><sup>2</sup>) channels
                  can be sealed using <em>O</em>(<em>n</em>) messages.
</font></blockquote>

</dd>


<dt>
[<a name="EvdMS:AiMLbook">16</a>]
</dt>
<dd>
~, Ron van&nbsp;der Meyden, and Kaile Su.
 Modal logics with a linear hierarchy of local propositional
  quantifiers.
 In Philippe Balbiani, Nobu-Yuki Suzuki, Frank Wolter, and Michael
  Zakharyaschev, editors, <em>Advances in Modal Logic</em>, volume&nbsp;4, pages 9&ndash;30.
  King's College London Publications, 2003.
[&nbsp;<a href="kai-e-pubs_bib.html#EvdMS:AiMLbook">bib</a>&nbsp;]
<blockquote><font size="-1">
Local propositions arise in the context of the
                  semantics for logics of knowledge in multi-agent
                  systems. A proposition is local to an agent when it
                  depends only on that agent's local state. We
                  consider a logic, LLP, that extends S5, the modal
                  logic of necessity (in which the modality refers to
                  truth at all worlds) by adding a quantifier ranging
                  over the set of all propositions and, for each
                  agent, a propositional quantifier ranging over the
                  agent's local propositions. LLP is able to express a
                  large variety of epistemic modalities, including
                  knowledge, common knowledge and distributed
                  knowledge. However, this expressiveness comes at a
                  cost: the logic is equivalent to second order
                  predicate logic when two independent agents are
                  present [<a href="#EvdMM98:TARK">22</a>], hence undecidable and
                  not axiomatizable. This paper identifies a class of
                  multi-agent S5 structures, <em>hierarchical
                  structures</em>, in which the agents' information has
                  the structure of a linear hierarchy. All systems
                  with just a single agent are hierarchical. It is
                  shown that LLP becomes decidable with respect to
                  hierarchical systems. The main result of the paper
                  is the completeness of an axiomatization for the
                  hierarchical case.
</font></blockquote>

</dd>


<dt>
[<a name="EvdMS2002:AiML">17</a>]
</dt>
<dd>
~, Ron van&nbsp;der Meyden, and Kaile Su.
 Modal logics with a linear hierarchy of local propositional
  quantifiers (preliminary version).
 In Nobu-Yuki Suzuki and Frank Wolter, editors, <em>Advances in Modal
  Logic 2002 (AiML)</em>, pages 63&ndash;76. Institut de recherche en informatique de
  Toulouse, Universit&eacute; Paul Sabatier, September 2002.
[&nbsp;<a href="kai-e-pubs_bib.html#EvdMS2002:AiML">bib</a>&nbsp;]

</dd>


<dt>
[<a name="E2002:Refine">18</a>]
</dt>
<dd>
~.
 Towards a refinement theory that supports reasoning about knowledge
  and time for multiple agents (work in progress).
 In John Derrick, Eerke Boiten, Jim Woodcock, and Joakim von Wright,
  editors, <em>REFINE '02 An FME sponsored Refinement Workshop in
  collaboration with BCS FACS</em>, page&nbsp;23. Computing Laboratory, University of
  Kent at Canterbury, UK, July 2002.
 Preliminary Proceedings.
[&nbsp;<a href="kai-e-pubs_bib.html#E2002:Refine">bib</a>&nbsp;]

</dd>


<dt>
[<a name="EvdMM2001:LPAR">19</a>]
</dt>
<dd>
~, Ron van&nbsp;der Meyden, and Yoram Moses.
 A refinement theory that supports reasoning about knowledge and time
  for synchronous agents.
 In Robert Nieuwenhuis and Andrei Voronkov, editors, <em>Proceedings
  LPAR 2001</em>, volume 2250 of <em>LNAI</em>, pages 125&ndash;141. Springer-Verlag,
  December 2001.
[&nbsp;<a href="kai-e-pubs_bib.html#EvdMM2001:LPAR">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/3-540-45653-8_9">DOI</a>&nbsp;]
<blockquote><font size="-1">
An expressive semantic framework for program
                  refinement that supports both temporal reasoning and
                  reasoning about the knowledge of multiple agents is
                  developed. The refinement calculus owes the
                  cleanliness of its decomposition rules for all
                  programming language constructs and the relative
                  simplicity of its semantic model to a rigid
                  synchrony assumption which requires all agents and
                  the environment to proceed in lockstep. The new
                  features of the calculus are illustrated in a
                  derivation of the two-phase-commit protocol.
</font></blockquote>

</dd>


<dt>
[<a name="EvdMM2000:FOSSACS">20</a>]
</dt>
<dd>
~, Ron van&nbsp;der Meyden, and Yoram Moses.
 A program refinement framework supporting reasoning about knowledge
  and time.
 In Jerzy Tiuryn, editor, <em>Foundations of Software Science and
  Computation Structures</em>, volume 1784 of <em>LNCS</em>, pages 114&ndash;129.
  Springer-Verlag, March 2000.
[&nbsp;<a href="kai-e-pubs_bib.html#EvdMM2000:FOSSACS">bib</a>&nbsp;]
<blockquote><font size="-1">
This paper develops a highly expressive semantic
                  framework for program refinement that supports both
                  temporal reasoning and reasoning about the knowledge
                  of a single agent. The framework generalizes a
                  previously developed temporal refinement framework
                  by amalgamating it with a logic of quantified local
                  propositions, a generalization of the logic of
                  knowledge. The combined framework provides a formal
                  setting for development of knowledge-based programs,
                  and addresses two problems of existing theories of
                  such programs: lack of compositionality and the fact
                  that such programs often have only implementations
                  of high computational complexity. Use of the
                  framework is illustrated by a control theoretic
                  example concerning a robot operating with an
                  imprecise position sensor.
</font></blockquote>

</dd>


<dt>
[<a name="EvdM99:wsproc">21</a>]
</dt>
<dd>
~ and Ron van&nbsp;der Meyden.
 Modal logics with a hierarchy of local propositional quantifiers
  (extended abstract).
 In Thomas Eiter, Georg Gottlob, Victor Marek, and Jeffrey Remmel,
  editors, <em>Proceedings of the FLoC'99 Workshop Complexity-Theoretic and
  Recursion-Theoretic Methods in Databases and Artificial Intelligence</em>, pages
  81&ndash;90, July 6 1999.
[&nbsp;<a href="kai-e-pubs_bib.html#EvdM99:wsproc">bib</a>&nbsp;]

</dd>


<dt>
[<a name="EvdMM98:TARK">22</a>]
</dt>
<dd>
~, Ron van&nbsp;der Meyden, and Yoram Moses.
 Knowledge and the logic of local propositions.
 In Itzhak Gilboa, editor, <em>Theoretical Aspects of Rationality and
  Knowledge, Proceedings of the Seventh Conference (TARK 1998)</em>, pages 29&ndash;41.
  Morgan Kaufmann, July 1998.
[&nbsp;<a href="kai-e-pubs_bib.html#EvdMM98:TARK">bib</a>&nbsp;]
<blockquote><font size="-1">
An agent's limited view of the state of a
                  distributed system may render globally different
                  situations indistinguishable. A proposition is local
                  for this agent whenever his view suffices to decide
                  this proposition. Motivated by a framework for the
                  development of distributed programs from
                  knowledge-based specifications, we introduce a modal
                  logic of local propositions, in which it is possible
                  to quantify over such propositions. We show that
                  this logic is able to represent a rich set of
                  epistemic notions. Under the usual strong semantics,
                  this logic is not recursively axiomatizable,
                  however. We show that by weakening the semantics of
                  quantification, it is possible to obtain a logic
                  that is axiomatizable and is still able to express
                  interesting epistemic notions.
</font></blockquote>

</dd>


<dt>
[<a name="EdR:cup98">23</a>]
</dt>
<dd>
Willem-Paul de&nbsp;Roever and ~.
 <em>Data Refinement: Model-Oriented Proof Methods and their
  Comparison</em>.
 Number&nbsp;47 in Cambridge Tracts in Theoretical Computer Science.
  Cambridge University Press, 1998.
 Paperback re-issue 2009. Errata at
  <a href="https://kai-e.github.io/pubs/dRE1998/errata.pdf">https://kai-e.github.io/pubs/dRE1998/errata.pdf</a>.
[&nbsp;<a href="kai-e-pubs_bib.html#EdR:cup98">bib</a>&nbsp;]

</dd>


<dt>
[<a name="E:PhD">24</a>]
</dt>
<dd>
~.
 <em>Model-Oriented Data Refinement</em>.
 PhD thesis, Institut f&uuml;r Informatik und Praktische Mathematik,
  Christian-Albrechts-Universit&auml;t zu Kiel, July 1997.
[&nbsp;<a href="kai-e-pubs_bib.html#E:PhD">bib</a>&nbsp;]
<blockquote><font size="-1">
The goal of this thesis is to provide a
                  comprehensive and systematic introduction to the
                  important and highly applicable method of data
                  refinement and proving simulation. We concentrate in
                  the first part on the general principles needed to
                  prove data refinement correct, and begin with an
                  explanation of the fundamental notions, showing that
                  data refinement proofs reduce to proving simulation.
                  The topics of Hoare Logic and the Refinement
                  Calculus are then introduced and a general theory of
                  simulations is developed and related to them.
                  Accessibility and comprehension are emphasised in
                  order to guide newcomers to the area. The second
                  part of this thesis contains a detailed survey of
                  important methods in this area, such as VDM, and the
                  methods due to Abadi &amp; Lamport, Hehner, Lynch and
                  Reynolds, and Back's refinement calculus. All these
                  methods are carefully analysed, and shown to be
                  either incomplete, with counterexamples to their
                  application, or to be always applicable whenever
                  data refinement holds. This is shown by proving, for
                  the first time, that all of them can be described
                  and analysed in terms of two simple notions: forward
                  and backward simulation.
</font></blockquote>

</dd>


<dt>
[<a name="EdR:liberPV">25</a>]
</dt>
<dd>
~ and Willem-Paul de&nbsp;Roever.
 New win[e/d] for old bags.
 In John Tromp, editor, <em>A dynamic and quick intellect, Paul
  Vit&aacute;nyi 25 years @ CWI</em>, pages 59&ndash;66. CWI, Amsterdam, November 1996.
[&nbsp;<a href="kai-e-pubs_bib.html#EdR:liberPV">bib</a>&nbsp;]

</dd>


<dt>
[<a name="EdR:mfcs96">26</a>]
</dt>
<dd>
~ and Willem-Paul de&nbsp;Roever.
 Simulation of specification statements in Hoare logic.
 In Wojciech Penczek and Andrzej Szalas, editors, <em>Mathematical
  Foundations of Computer Science 1996, 21st International Symposium, MFCS
  '96, Cracow, Poland, Proceedings</em>, volume 1113 of <em>LNCS</em>, pages
  324&ndash;335. Springer-Verlag, September 1996.
[&nbsp;<a href="kai-e-pubs_bib.html#EdR:mfcs96">bib</a>&nbsp;]
<blockquote><font size="-1">
Data refinement is a powerful technique to derive
                  implementations in terms of low-level data
                  structures like bytes from specification in terms of
                  high-level data structures like queues. The higher
                  level operations need not be coded as ordinary
                  programs; it is more convenient to introduce
                  specification statements to the programming language
                  and use them instead of actual code. Specification
                  statements represent the maximal program satisfying
                  a given Hoare-triple. Sound and (relatively)
                  complete simulation techniques allow for proving
                  data refinement by local arguments. A major
                  challenge for simulation consists of expressing the
                  weakest lower level specification simulating a given
                  higher level specification w.r.t. a given relation
                  between these two levels of abstraction. We present
                  solutions to this challenge for upward and downward
                  simulation in both partial and total correctness
                  frameworks, thus reducing the task of proving data
                  refinement to proving validity of certain
                  Hoare-triples.
</font></blockquote>

</dd>


<dt>
[<a name="EdR:facs95">27</a>]
</dt>
<dd>
~ and Willem-Paul de&nbsp;Roever.
 Towards a practitioners' approach to Abadi and Lamport's method.
 <em>Formal Aspects of Computing</em>, 7(5):550&ndash;575, 1995.
[&nbsp;<a href="kai-e-pubs_bib.html#EdR:facs95">bib</a>&nbsp;]
<blockquote><font size="-1">
Our own basic intuitions are presented when
                  introducing the method developed by Abadi and
                  Lamport in [?] for proving refinement
                  between specifications of nondeterministic programs
                  correct to people unacquainted with it. The example
                  we use to illustrate this method is a nontrivial
                  communication protocol that provides a mechanism
                  analogous to message passing between migrating
                  processes within a fixed finite network of nodes due
                  to Kleinman, Moscowitz, Pnueli, and
                  Shapiro [?]. Especially the cruel last
                  step of a three step refinement proof of that
                  protocol gives rise to a deeper understanding of,
                  and some small enhancements to, Abadi and Lamport's
                  1988 method.
</font></blockquote>

</dd>


<dt>
[<a name="EdR:fme93">28</a>]
</dt>
<dd>
~ and Willem-Paul de&nbsp;Roever.
 Generalizing Abadi &amp; Lamport's method to solve a problem posed
  by A. Pnueli.
 In Jim&nbsp;C.P. Woodcock and Peter&nbsp;Gorm Larsen, editors, <em>FME '93:
  Industrial-Strength Formal Methods</em>, volume 670 of <em>LNCS</em>, pages
  294&ndash;313. Springer-Verlag, April 1993.
[&nbsp;<a href="kai-e-pubs_bib.html#EdR:fme93">bib</a>&nbsp;]

</dd>


<dt>
[<a name="E:master93">29</a>]
</dt>
<dd>
~.
 Verallgemeinerungen der Methode von Abadi und Lamport um ein von A.
  Pnueli gestelltes Problem zu l&ouml;sen.
 Master's thesis, Institut f&uuml;r Informatik und Praktische
  Mathematik, Christian-Albrechts-Universit&auml;t zu Kiel, January 1993.
[&nbsp;<a href="kai-e-pubs_bib.html#E:master93">bib</a>&nbsp;]
<blockquote><font size="-1">
By adding a new technique and a simple proof
                  strategy to Abadi &amp; Lamport's 1988 method
                  [?] for proving refinement between
                  specifications of distributed programs correct, the
                  inherent limitation of their method, occurring when
                  the abstract level of specification features
                  so-called infinite invisible nondeterminism or
                  internal discontinuity, can be sometimes overcome.
                  This technique is applied to the cruel last step of
                  a three step correctness proof for an algorithm for
                  communication between migrating processes within a
                  finite network due to Kleinman, Moscowitz, Pnueli &amp;
                  Shapiro [?].
</font></blockquote>

</dd>
</dl>